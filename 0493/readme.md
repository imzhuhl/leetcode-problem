困难题



#### 思路一

最简单的做法就是暴力遍历，时间复杂度 $O(n^2)$。



#### 思路二

本题必须要要进行两两比较，最好的结果是用有序的方式完成比较，例如二分查找，这样可以将时间复杂度简化到 $O(nlogn)$。

例如，逆序开始遍历数组，然后将遍历得到的数插入一个平衡二叉查找树（AVL），这样每次遍历一个数组，就在相应的 AVL中查找，额外的需要在每一个节点中维护一组数据，记录左子树有多少节点，右子树有多少节点，这需要自定义 AVL 的插入、旋转操作。（未实现，纯思路）



#### 思路三：归并排序

对于两个升序区间，`a[start, mid] 和 a[mid+1, end]`，每一个 $i \in (start, mid)$ 和 $j \in (mid+1, end)$，我们判断是否 $a[i] > 2 \times a[j]$ 。如果成立，则在 `mid+1` 到 `j` 之间的数必定都满足，记录个数即可，随着 `i` 的增大，`j`不会变小，因此，对这两个区间来说，找出满足题目的解的时间复杂度是线性的，这和两个区间合并的时间复杂度一致，因此对于整体，完成归并排序的时间复杂度就是该题的时间复杂度 `O(nlogn)`。

